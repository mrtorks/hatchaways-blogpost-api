require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe Api::PostsController, type: :request do
  # This should return the minimal set of attributes required to create a valid
  # Post. As you add validations to Post, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes) do
    skip('Add a hash of attributes valid for your model')
  end

  let(:invalid_attributes) do
    skip('Add a hash of attributes invalid for your model')
  end

  # This should return the minimal set of values that should be in the headers
  # in order to pass any filters (e.g. authentication) defined in
  # PostsController, or in your router and rack
  # middleware. Be sure to keep this updated too.
  let(:valid_headers) { {} }

  describe 'GET api/posts' do
   
    
    context do
      it 'should be successful' do
        puts '--------------------------------------------------------------------'
        puts 'Begin Testing......'
        puts '--------------------------------------------------------------------'
        puts '--------------------------------------------------------------------'
        puts 'Testing with one tag'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'tech' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['tags']).to include('tech')
        expect(JSON.parse(response.body)['posts'][0]['id']).to be(1)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful in descending order' do
        get '/api/posts', params: { tags: 'tech', direction: 'desc' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be(99)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful sorted by likes' do
        get '/api/posts', params: { tags: 'tech', sortBy: 'likes' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful sorted by reads' do
        get '/api/posts', params: { tags: 'tech', sortBy: 'reads' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful sorted by popularity' do
        get '/api/posts', params: { tags: 'tech', sortBy: 'popularity' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful sorted by id in desc' do
        get '/api/posts', params: { tags: 'tech', sortBy: 'id', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(80, 100)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end
    end

    context do
      it 'should be successful with two tags' do
        puts '--------------------------------------------------------------------'
        puts 'Testing with two tags'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'tech,politics' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(0, 10)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful with two tags in desc' do
        get '/api/posts', params: { tags: 'tech,politics', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(80, 100)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful with two tags sorted by likes in desc' do
        get '/api/posts', params: { tags: 'tech,politics', sortBy: 'likes', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end
    end

    context do
      it 'should be successful with three tags' do
        puts '--------------------------------------------------------------------'
        puts 'Testing with three tags'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'tech,politics,culture' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(0, 10)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful with three tags in desc' do
        get '/api/posts', params: { tags: 'tech,politics,culture', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(80, 100)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful with three tags osorted by reads in desc ' do
        get '/api/posts', params: { tags: 'tech,politics,culture', sortBy: 'reads', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end
    end

    context do 
      it 'successful with four tags' do
        puts '--------------------------------------------------------------------'
        puts 'Testing with four of tags'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'tech,politics,culture,history' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(0, 10)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

      it 'should be successful with four tags in desc' do
        get '/api/posts', params: { tags: 'tech,politics,culture,history', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(JSON.parse(response.body)['posts'][0]['id']).to be_between(80, 100)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful
      end

    

      it 'should be successful with four tags sorted by popularity in desc ' do
        get '/api/posts', params: { tags: 'tech,politics,culture,history', sortBy: 'popularity', direction: 'desc'}
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts'].count).to be_between(30, 80)
        expect(JSON.parse(response.body)['posts'].count).not_to be_between(0, 19)
        expect(response).to match_response_schema('posts')
        expect(response).to be_successful 
      end
    end


    # Wrong tag that passes using proper conditions
    context do
      it 'should be successful & empty with an invalid tag' do
        puts '--------------------------------------------------------------------'
        puts 'Valid Tests complete'
        puts '--------------------------------------------------------------------'
        puts '--------------------------------------------------------------------'
        puts 'Invalid Passing Test Begins'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'id' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts']).to be_empty
        expect(JSON.parse(response.body)['posts'].count).to be_between(0, 19)
        expect(response).to match_response_schema('posts')
      end

      it 'should be successful and empty with an invalid tag, valid sort & direction' do
        get '/api/posts', params: { tags: 'id', sortBy: 'likes', direction: 'desc' }
        expect(response).to have_http_status(:success)
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts']).to be_empty
        expect(JSON.parse(response.body)['posts'].count).to be_between(0, 19)
        expect(response).to match_response_schema('posts')
      end
    end

    context do
      it 'should fail with an invalid tag' do
        puts '--------------------------------------------------------------------'
        puts 'Invalid Passing Test Ends'
        puts '--------------------------------------------------------------------'
        puts '--------------------------------------------------------------------'
        puts 'Invalid Failing Test Begins'
        puts '--------------------------------------------------------------------'
        get '/api/posts', params: { tags: 'id' }
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts']).not_to be_empty
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(response).to have_http_status(:bad_request) # should fail however returns success with empty object so this fails
      end

      it 'should fail with an invalid tag, valid sort & direction' do
        get '/api/posts', params: { tags: 'id', sortBy: 'likes', direction: 'desc' }
        expect(JSON.parse(response.body)).to be_an_instance_of Hash
        expect(JSON.parse(response.body).count).to eq(1)
        expect(JSON.parse(response.body)['posts']).not_to be_empty
        expect(JSON.parse(response.body)['posts'].count).to be_between(20, 30)
        expect(response).to have_http_status(:bad_request) # should fail however returns success with empty object so this fails
      end
    end
  end

  #describe "GET /show" do
  #  it "renders a successful response" do
  #    post = Post.create! valid_attributes
  #    get post_url(post), as: :json
  #    expect(response).to be_successful
  #  end
  #end

  #describe "POST /create" do
  #  context "with valid parameters" do
  #    it "creates a new Post" do
  #      expect {
  #        post posts_url,
  #             params: { post: valid_attributes }, headers: valid_headers, as: :json
  #      }.to change(Post, :count).by(1)
  #    end

  #    it "renders a JSON response with the new post" do
  #      post posts_url,
  #           params: { post: valid_attributes }, headers: valid_headers, as: :json
  #      expect(response).to have_http_status(:created)
  #      expect(response.content_type).to match(a_string_including("application/json"))
  #    end
  #  end

  #  context "with invalid parameters" do
  #    it "does not create a new Post" do
  #      expect {
  #        post posts_url,
  #             params: { post: invalid_attributes }, as: :json
  #      }.to change(Post, :count).by(0)
  #    end

  #    it "renders a JSON response with errors for the new post" do
  #      post posts_url,
  #           params: { post: invalid_attributes }, headers: valid_headers, as: :json
  #      expect(response).to have_http_status(:unprocessable_entity)
  #      expect(response.content_type).to eq("application/json")
  #    end
  #  end
  #end

  #describe "PATCH /update" do
  #  context "with valid parameters" do
  #    let(:new_attributes) {
  #      skip("Add a hash of attributes valid for your model")
  #    }

  #    it "updates the requested post" do
  #      post = Post.create! valid_attributes
  #      patch post_url(post),
  #            params: { post: new_attributes }, headers: valid_headers, as: :json
  #      post.reload
  #      skip("Add assertions for updated state")
  #    end

  #    it "renders a JSON response with the post" do
  #      post = Post.create! valid_attributes
  #      patch post_url(post),
  #            params: { post: new_attributes }, headers: valid_headers, as: :json
  #      expect(response).to have_http_status(:ok)
  #      expect(response.content_type).to match(a_string_including("application/json"))
  #    end
  #  end

  #  context "with invalid parameters" do
  #    it "renders a JSON response with errors for the post" do
  #      post = Post.create! valid_attributes
  #      patch post_url(post),
  #            params: { post: invalid_attributes }, headers: valid_headers, as: :json
  #      expect(response).to have_http_status(:unprocessable_entity)
  #      expect(response.content_type).to eq("application/json")
  #    end
  #  end
  #end

  #describe "DELETE /destroy" do
  #  it "destroys the requested post" do
  #    post = Post.create! valid_attributes
  #    expect {
  #      delete post_url(post), headers: valid_headers, as: :json
  #    }.to change(Post, :count).by(-1)
  #  end
  #end
end
